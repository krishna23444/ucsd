/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */



#ifndef ENABLE_NLS
#define ENABLE_NLS 1
#endif
#include "Params.h"

#include "services/TritonShare/TritonShare.h"
#include "services/TritonShare/TritonShare-init.h"

#include "services/Http/HttpClient.h"
#include "services/Http/HttpServer.h"

#include "Util.h"
#include <iostream>

#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <string>
#include <iostream>
#include "TritonShare_nogui.h"
// extern "C" {
// #include "lib/license.h"
// }


//Global variables
HttpServer * http_server;
MyHttpClientResponseHandler myHttpClientResponseHandler;
P2PServiceClass *globalMacedon;

//void ReplayTreeTest_load_protocol();
using namespace mace;

void PrintUsage(char *executable)
{
  fprintf(stderr, "Usage: %s [params file]\n", executable);
  fprintf(stderr, "params file must include: \n");
  fprintf(stderr, "\tpeer\n\tpeer_port\n\tbandwidth\n\tshare (directory to share)\n");
  fprintf(stderr, "\thttp_port\n\tMACE_PORT (port our peers will connect to us on\n");
}



class row_entry{
public:
  MaceKey user;
  int port;
  mace::string fileName;
  
  row_entry( MaceKey u, int p, mace::string fn)
    :user(u), port(p), fileName(fn)
  {
  }
  row_entry()
    {
    }
};


// This is where we define the P2P handler which will deal with all the upcalls
class MyP2PHandler : public P2PHandler {
public:
  void joinStatusChanged(join_status_t newstatus, registration_uid_t rid)
  {
    char *newStatus;
    switch(newstatus)
    {
    case(P2P_DISCONNECTED):
      newStatus = "Status: Disconnected";
      break;
    case(P2P_JOINING):
      newStatus = "Status: Connecting";
      break;
    case(P2P_CLIENT_JOINED):
      newStatus = "Status: Connected as Client";
      break;
    case(P2P_SUPERNODE_JOINED):
      newStatus = "Status: Connected as Supernode";
      break;
    default:
      newStatus = "Status: Error: Bad case";
    }
    fprintf(stderr, "\n\n!!!!!Got an upcall, new status: %s (%d)!!!!!\n\n",
           newStatus, newstatus);
  }
  
  FileSet getAvailableFiles(registration_uid_t rid)
  {
    //Open specified directory
    string path = Params::Instance()->getStr("share");
    
    //Remove trailing / if one exists
    
    if(path.substr(path.size()-1,  string::npos) == "/")
      path = path.substr(0, path.size()-1);


    DIR *dir = opendir(path.c_str());
    if(!dir)
    {
      fprintf(stderr, "\nShared directory is now invalid\n");
      exit(0);
      //Fix : quit more gracefully
    }

    FileSet myFiles; 

    
    //Read directory and insert read files into set
    struct dirent *dirp;
    string workingPath;
    struct stat statbuf;
    while( (dirp = readdir(dir)) != NULL )
    {
      //ignore entries . and ..
      if( strcmp(dirp->d_name, ".") == 0 ||
	  strcmp(dirp->d_name, "..") == 0)
	continue;
      
      //ignore directories
      workingPath = path + "/" + string(dirp->d_name);
      if(stat(workingPath.c_str(), &statbuf) < 0)
	continue;
      
      if(S_ISDIR(statbuf.st_mode) != 0)
	continue;

      //otherwise, add it to the list
      myFiles.insert( std::string(dirp->d_name) );
    }


    closedir(dir);
    return myFiles;    
  }


  row_entry GetRow(int rowNum)
  {
    row_entry r = Rows[rowNum];    
    return Rows[rowNum];
  }

  void newQuery(std::string query)
  {
    Rows.clear();
    column_count = 0;
    currQuerySeqNum = globalMacedon->queryP2P(query);    

  }
  

  void handleQueryResult( uint sequence_num, 
			  const QueryResultSet& results, 
			  registration_uid_t registrationUid )
  {
    QueryResultSet::const_iterator i;
    for(i = results.begin(); i != results.end(); i++)
    {
      FileSet::const_iterator j;
      for(j = i->files.begin(); j != i->files.end(); j++)
      {	  
	Rows[column_count] = row_entry(i->peer, i->port, *j);
	//myGuiManager->Push_Search_Result(column_count++, i->peer, *j);
      }
    }
  }

// Variables
public:
  mace::hash_map<int, row_entry> Rows;
  int currQuerySeqNum;
  int column_count;

} myP2PHandler;



// Some varoius functions

void Do_Query(char *query)
{
  string query_str = string(query);
  if(query_str != "")
    myP2PHandler.newQuery(query_str);
}

void Handle_Row_Activated(int rowNum)
{
  row_entry row = myP2PHandler.GetRow(rowNum);
  Do_Get_File(row.user, row.port, row.fileName.c_str());
}

void Do_Get_File(MaceKey server, int port, const char *filename)
{
  // string hostName = string(Util::getHostByAddr(server.getInAddr().s_addr));
  string hostName = server.addressString();
  string getPath = string("/") + string(filename);
  HttpClient *myHttpClient = new HttpClient(hostName, port);
  myHttpClient->getUrlAsync(getPath, "1.1", true, &myHttpClientResponseHandler, &HttpClientResponseHandler::getRequestResult);
}


double now_time()
{
  double ret;
  timeval clock_;
  struct timezone tz_;
  gettimeofday(&clock_, &tz_);
  ret = (clock_.tv_sec+(double)clock_.tv_usec/1000000.0);
  return ret;
}



#define COL_NAME 0
#define COL_AGE 1
#define NUM_COLS 2




int main (int argc, char **argv)
{

  ////////////////////////////////////////////////////////////
  // Code for setting up the initial GUI
  ////////////////////////////////////////////////////////////

  /*CalALumWindow = create_CalALumWindow ();
  GtkWidget *ptr = lookup_widget(CalALumWindow, "networkStatusBar");
  gtk_statusbar_push((GtkStatusbar *)ptr, 1, "Status: Disconnected");
  gtk_widget_show (CalALumWindow);


  GtkWidget *treeview1 = lookup_widget(CalALumWindow, "treeview1");    

  GtkCellRenderer     *renderer;
  renderer = gtk_cell_renderer_text_new ();
  gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (treeview1),
                                               -1,      
                                               "Count",  
                                               renderer,
                                               "text", GuiManager::GUI_COUNT_COLUMN,
                                               NULL);

  renderer = gtk_cell_renderer_text_new ();
  gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (treeview1),
                                               -1,      
                                               "Peer",  
                                               renderer,
                                               "text", GuiManager::GUI_IP_COLUMN,
                                               NULL);



  renderer = gtk_cell_renderer_text_new ();
  gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (treeview1),
                                               -1,      
                                               "File Name",  
                                               renderer,
                                               "text", GuiManager::GUI_FILENAME_COLUMN,
                                               NULL);


  GtkListStore *store = gtk_list_store_new (3, G_TYPE_INT, G_TYPE_STRING, G_TYPE_STRING );
  gtk_tree_view_set_model( GTK_TREE_VIEW (treeview1), GTK_TREE_MODEL(store));
  g_object_unref( store );
  
  myGuiManager = new GuiManager( (GtkStatusbar *)ptr, store );
  */

  // First load running parameters 
  Log::autoAdd("TritonShare");
  Params::Instance()->loadparams(argc, argv);
  Params::Instance()->print(stdout);

  // load_protocols();

  if (!Params::Instance()->containsKey("MACE_PORT")) 
  {
    fprintf(stderr, "Bad MACE_PORT\n");
    PrintUsage(argv[0]);
    exit(0);
  }
  if(!Params::Instance()->containsKey("peer"))
  {
    fprintf(stderr, "Bad Peer\n");
    PrintUsage(argv[0]);
    exit(0);
  }

  if(!Params::Instance()->containsKey("peer_port"))
  {
    fprintf(stderr, "Peer port not specified\n");
    PrintUsage(argv[0]);
    exit(0);
  }
  if(!Params::Instance()->containsKey("share"))
  {
    fprintf(stderr, "Bad shared directory\n");
    PrintUsage(argv[0]);
    exit(0);
  }
  if(!Params::Instance()->containsKey("bandwidth"))
  {
    fprintf(stderr, "Bad bandwidth\n");
    PrintUsage(argv[0]);
    exit(0);
  }
  if(!Params::Instance()->containsKey("http_port"))
  {
    fprintf(stderr, "Bad service port\n");
    PrintUsage(argv[0]);
    exit(0);
  }

  //Startup the http server
  int port = Params::Instance()->getInt("http_port");
  http_server = new HttpServer(port);
  http_server->setDocumentRoot(Params::Instance()->getStr("share"));

  // http_server->registerUrlHandler("/foo.html", myUrlHandler);
  try 
  {
    http_server->run();
  }
  catch(const Exception& e) 
  {
    std::cerr<<e<<std::endl;
    assert(0);
  }



  
  //Verify the directory entry points to a valid 1directory
  DIR *dir = opendir(Params::Instance()->getStr("share"));
  if(dir == NULL)
  {
    fprintf(stderr, "Error - specified shared directory is invalid\n");
    exit(0);
  }
  closedir(dir);


  // Initialize the random seed
  double time_r = now_time();
  srand48((int)(1000000 * (time_r - (int)time_r)));

  // Initialize mace key with the string "addr:port"
  string addrPort = Params::Instance()->getStr("peer");
  addrPort += ":";
  addrPort += Params::Instance()->getStr("peer_port");

  MaceKey peer = MaceKey(ipv4, addrPort);

  globalMacedon = &TritonShare_namespace::new_TritonShare_P2P();
  registration_uid_t  myHandler = globalMacedon->registerHandler(myP2PHandler);
  globalMacedon->maceInit();
  fprintf(stderr, "-->Joining P2P\n");
  globalMacedon->joinP2P(peer, Params::Instance()->getDouble("bandwidth"),
			 port, "", myHandler);
  fprintf(stderr, "-->Done joining P2P\n");

  fprintf(stderr, "-->Sleeping for 30 seconds\n");
  sleep(30);
  fprintf(stderr, "-->Done sleeping for 30 seconds\n");

  char *query = "music";
  fprintf(stderr, "-->Querying for %s\n", query);
  Do_Query(query);
  fprintf(stderr, "-->Done querying for %s\n", query);

  fprintf(stderr, "-->Sleeping for 20 more seconds\n");
  sleep(20);
  fprintf(stderr, "-->Done sleeping for 20 more seconds\n");

  globalMacedon->leaveP2P();
  globalMacedon->maceExit();
  _exit(0);
  return 0;

}
