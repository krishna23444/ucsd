/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#include <gdk/gdkkeysyms.h>
#include <gtk/gtk.h>
#ifndef ENABLE_NLS
#define ENABLE_NLS 1
#endif
#include "interface.h"
#include "support.h"

#include "Params.h"

#include "services/TritonShare/TritonShare.h"
#include "services/TritonShare/TritonShare-init.h"

#include "services/Http/HttpClient.h"
#include "services/Http/HttpServer.h"

#include "Util.h"
#include <iostream>

#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <string>
#include <iostream>
#include "TritonShare_gui.h"
// extern "C" {
// #include "lib/license.h"
// }


//Global variables
HttpServer * http_server;
MyHttpClientResponseHandler myHttpClientResponseHandler;
P2PServiceClass *globalMacedon;
GtkWidget *CalALumWindow;
GuiManager * myGuiManager;

//void ReplayTreeTest_load_protocol();
using namespace mace;

void PrintUsage(char *executable) {
  printf("Usage: %s [params file]\n", executable);
  printf("params file must include: \n");
  printf("\tpeer\n\tpeer_port\n\tbandwidth\n\tshare (directory to share)\n");
  printf("\thttp_port\n\tMACE_PORT (port our peers will connect to us on\n");
}


class row_entry{
public:
  MaceKey user;
  int port;
  mace::string fileName;
  
  row_entry( MaceKey u, int p, mace::string fn)
      :user(u), port(p), fileName(fn) {
  }
  
  row_entry() {
  }
};


// This is where we define the P2P handler which will deal with all the upcalls
class MyP2PHandler : public P2PHandler {
public:
  void joinStatusChanged(join_status_t newstatus, registration_uid_t rid) {
    printf("\n\n!!!!!Got an upcall, new status: %d!!!!!\n\n", newstatus);
    string newStatus = string(Params::Instance()->getStr("MACE_PORT")) + " - ";
    switch (newstatus) {
    case (P2P_DISCONNECTED):
      newStatus += "Disconnected";
      break;
    case (P2P_JOINING):
      newStatus += "Connecting";
      break;
    case (P2P_CLIENT_JOINED):
      newStatus += "Client";
      break;
    case (P2P_SUPERNODE_JOINED):
      newStatus += "Supernode";
      break;
    default:
      newStatus += "Error: Bad case";
    }
    
    gtk_window_set_title(GTK_WINDOW(CalALumWindow), newStatus.c_str());
    myGuiManager->Update_Status_Bar(newStatus);
  }
  
  FileSet getAvailableFiles(registration_uid_t rid) {
    //Open specified directory
    string path = Params::Instance()->getStr("share");
    
    //Remove trailing / if one exists
    if (path.substr(path.size()-1,  string::npos) == "/")
      path = path.substr(0, path.size()-1);

    DIR *dir = opendir(path.c_str());
    if (!dir) {
      printf("\nShared directory is now invalid\n");
      exit(0);
      //Fix : quit more gracefully
    }

    FileSet myFiles; 

    //Read directory and insert read files into set
    struct dirent *dirp;
    string workingPath;
    struct stat statbuf;
    while ((dirp = readdir(dir)) != NULL) {
      //ignore entries . and ..
      if( strcmp(dirp->d_name, ".") == 0 || strcmp(dirp->d_name, "..") == 0)
        continue;
      
      //ignore directories
      workingPath = path + "/" + string(dirp->d_name);
      if(stat(workingPath.c_str(), &statbuf) < 0)
        continue;
      
      if(S_ISDIR(statbuf.st_mode) != 0)
        continue;

      //otherwise, add it to the list
      myFiles.insert( std::string(dirp->d_name) );
    }

    closedir(dir);
    return myFiles;    
  }


  row_entry GetRow(int rowNum) {
    row_entry r = Rows[rowNum];    
    return Rows[rowNum];
  }

  void newQuery(std::string query) {
    Rows.clear();
    column_count = 0;
    myGuiManager->Clear_Search_Results();
    currQuerySeqNum = globalMacedon->queryP2P(query);
  }

  void handleQueryResult(uint sequence_num, const QueryResultSet& results, 
                         registration_uid_t registrationUid) {
    QueryResultSet::const_iterator i;
    for(i = results.begin(); i != results.end(); i++) {
      FileSet::const_iterator j;
      for(j = i->files.begin(); j != i->files.end(); j++) {    
        Rows[column_count] = row_entry(i->peer, i->port, *j);
        myGuiManager->Push_Search_Result(column_count++, i->peer, *j);
      }
    }
  }

  // Variables
 public:
  mace::hash_map<int, row_entry> Rows;
  int currQuerySeqNum;
  int column_count;
} myP2PHandler;


// Some varoius functions

void Do_Query(char *query) {
  string query_str = string(query);
  if (query_str != "")
    myP2PHandler.newQuery(query_str);
}

void Handle_Row_Activated(int rowNum) {
  row_entry row = myP2PHandler.GetRow(rowNum);
  Do_Get_File(row.user, row.port, row.fileName.c_str());
}

void Do_Get_File(MaceKey server, int port, const char *filename) {
  // string hostName = string(Util::getHostByAddr(server.getInAddr().s_addr));
  string hostName = server.addressString();
  string getPath = string("/") + string(filename);
  HttpClient *myHttpClient = new HttpClient(hostName, port);
  myHttpClient->getUrlAsync(getPath, "1.1", true,
                            &myHttpClientResponseHandler,
                            &HttpClientResponseHandler::getRequestResult);
}

double now_time() {
  double ret;
  timeval clock_;
  struct timezone tz_;
  gettimeofday(&clock_, &tz_);
  ret = (clock_.tv_sec + (double)clock_.tv_usec / 1000000.0);
  return ret;
}

#define COL_NAME 0
#define COL_AGE 1
#define NUM_COLS 2

int main (int argc, char **argv) {
  gtk_set_locale ();
  gtk_init (&argc, &argv);

  ////////////////////////////////////////////////////////////
  // Code for setting up the initial GUI
  ////////////////////////////////////////////////////////////

  CalALumWindow = create_CalALumWindow();
  GtkWidget *ptr = lookup_widget(CalALumWindow, "networkStatusBar");
  gtk_statusbar_push((GtkStatusbar *)ptr, 1, "Status: Disconnected");
  gtk_widget_show (CalALumWindow);


  GtkWidget *treeview1 = lookup_widget(CalALumWindow, "treeview1");    

  GtkCellRenderer *renderer;
  renderer = gtk_cell_renderer_text_new ();
  gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW (treeview1), -1,      
                                              "Count", renderer,
                                              "text", GuiManager::GUI_COUNT_COLUMN,
                                              NULL);

  renderer = gtk_cell_renderer_text_new ();
  gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW (treeview1), -1,      
                                              "Peer", renderer,
                                              "text", GuiManager::GUI_IP_COLUMN,
                                              NULL);



  renderer = gtk_cell_renderer_text_new ();
  gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW (treeview1), -1,      
                                              "File Name", renderer, "text",
                                              GuiManager::GUI_FILENAME_COLUMN,
                                              NULL);


  GtkListStore *store = gtk_list_store_new (3, G_TYPE_INT, G_TYPE_STRING, G_TYPE_STRING );
  gtk_tree_view_set_model( GTK_TREE_VIEW (treeview1), GTK_TREE_MODEL(store));
  g_object_unref( store );
  
  myGuiManager = new GuiManager( (GtkStatusbar *)ptr, store );
  
  // First load running parameters 
  Log::autoAdd("TritonShare");
  Params::Instance()->loadparams(argc, argv);
  Params::Instance()->print(stdout);

  // load_protocols();

  if (!Params::Instance()->containsKey("MACE_PORT")) {
    printf("Bad MACE_PORT\n");
    PrintUsage(argv[0]);
    exit(0);
  }
  if (!Params::Instance()->containsKey("peer")) {
    printf("Bad Peer\n");
    PrintUsage(argv[0]);
    exit(0);
  }
  if (!Params::Instance()->containsKey("peer_port")) {
    printf("Peer port not specified\n");
    PrintUsage(argv[0]);
    exit(0);
  }
  if (!Params::Instance()->containsKey("share")) {
    printf("Bad shared directory\n");
    PrintUsage(argv[0]);
    exit(0);
  }
  if (!Params::Instance()->containsKey("bandwidth")) {
    printf("Bad bandwidth\n");
    PrintUsage(argv[0]);
    exit(0);
  }
  if (!Params::Instance()->containsKey("http_port")) {
    printf("Bad service port\n");
    PrintUsage(argv[0]);
    exit(0);
  }

  //Startup the http server
  int port = Params::Instance()->getInt("http_port");
  http_server = new HttpServer(port);
  http_server->setDocumentRoot(Params::Instance()->getStr("share"));

  // http_server->registerUrlHandler("/foo.html", myUrlHandler);
  try {
    http_server->run();
  }
  catch(const Exception& e) {
    std::cerr<<e<<std::endl;
    assert(0);
  }

  //Verify the directory entry points to a valid 1directory
  DIR *dir = opendir(Params::Instance()->getStr("share"));
  if(dir == NULL) {
    printf("Error - specified shared directory is invalid\n");
    exit(0);
  }
  closedir(dir);

  // Initialize the random seed
  double time_r = now_time();
  srand48((int)(1000000 * (time_r - (int)time_r)));

  // Initialize mace key with the string "addr:port"
  string addrPort = Params::Instance()->getStr("peer");
  addrPort += ":";
  addrPort += Params::Instance()->getStr("peer_port");

  MaceKey peer = MaceKey(ipv4, addrPort);

  // globalMacedon = &TritonShare_namespace::new_TritonShare_P2P();
  globalMacedon = &TritonShare_namespace::new_TritonShare_P2P();
  registration_uid_t  myHandler = globalMacedon->registerHandler(myP2PHandler);
  globalMacedon->maceInit();
  globalMacedon->joinP2P(peer, Params::Instance()->getDouble("bandwidth"),
                         port, "", myHandler);

  gtk_main();

  // globalMacedon->maceExit();
  _exit(0);
  return 0;
}
